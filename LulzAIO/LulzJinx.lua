-- if myHero.charName ~= "Ezreal" then return end
-- assert(load(Base64Decode("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"), nil, "bt", _ENV))()
-- TrackerLoad("F3lHB1VyjuAmxYnp")

class "Jinx"
function Jinx:__init()
    self.QState, self.WState, self.EState = nil, nil, nil
    self.manaPercent = nil
    self.print,self.PrintChat = _G.print, _G.PrintChat
    self.lastBardRCoords = {x = 0, z = 0, time = 0, ulted = false}
    self.castTime = 0
    self.SpellTable = {
        Q = {range = 1150, speed = 2000, delay = 0.25, width = 75, collision = true},
        W = {range = 1000, speed = 1550, delay = 0.25, width = 100, collision = false},
        E = {range = 475, maxRange = 750},
        R = {range = 9999, speed = 2500, delay = .6, width = 150, collision = true}
    }

    self.spellDmg = {
        [_Q] = function(unit) if self.QState then return myHero:CalcMagicDamage(unit, ((((myHero:GetSpellData(_Q).level * 20) + 15) + (myHero.ap * 0.4)) + (myHero.totalDamage * 1.1))) end end,
        [_W] = function(unit) if self.WState then return myHero:CalcMagicDamage(unit, (((myHero:GetSpellData(_W).level * 45) + 25) + (myHero.ap * 0.8))) end end,
        [_E] = function(unit) if self.EState then return myHero:CalcMagicDamage(unit, ((((myHero:GetSpellData(_E).level * 50) + 25) + (myHero.ap * 0.75)) + (myHero.addDamage * 0.5))) end end,
        [_R] = function(unit) if self.RState then return myHero:CalcMagicDamage(unit, ((((myHero:GetSpellData(_R).level * 150) + 200) + (myHero.ap * 0.9)) + myHero.addDamage)) end end
    }
    self.BaseSpots = {
                D3DXVECTOR3(396,182.132,462),
                D3DXVECTOR3(14340.418,171.9777,14391.075)
            }

    self.enemyHeros = GetEnemyHeroes()
    self.enemyMinions = minionManager(MINION_ENEMY, self.SpellTable.Q.range - 400, myHero, MINION_SORT_HEALTH_ASC)
    self.jungleMinions = minionManager(MINION_JUNGLE, 625, myHero, MINION_SORT_MAXHEALTH_ASC)

    self.recallStatus = {}
    self.recallTimes = {
    	['recall'] = 7.9,
    	['odinrecall'] = 4.4,
    	['odinrecallimproved'] = 3.9,
    	['recallimproved'] = 6.9,
    	['superrecall'] = 3.9,
    }
    self.activeRecalls = {}
    self.lasttime={}

    for i, enemy in pairs(self.enemyHeros) do
    	self.recallStatus[enemy.charName] = enemy.recall
    end
    for i, hero in pairs(GetAllyHeroes()) do
        if self.autoRTable[hero.charName] then
            LulzMenu.Spell.RMenu:addParam(hero.charName, "Use on " .. hero.charName .. " Ultimate", 1, true)
        end
    end

    self:AddToMenu()
    AddTickCallback(function() self:OnTick() end)
    AddTickCallback(function()
    	for i, enemy in pairs(self.enemyHeros) do
    		if enemy.recall ~= self.recallStatus[enemy.charName] then
    			self:recallFunction(enemy, enemy.recall)
    		end
    		self.recallStatus[enemy.charName] = enemy.recall
    	end
    end)
    AddDrawCallback(function() self:OnDraw() end)
end
function Jinx:BaseUlt()
    if not myHero.dead and LulzMenu.Spell.RMenu.BaseUlt then
        self.time = GetDistance(myHero, self.BaseSpots[2]) / 2000
        for i, snipeTarget in pairs(self.activeRecalls) do
            if (snipeTarget.endT - os.clock()) <= self.time + .6 and (snipeTarget.endT - os.clock()) >= self.time + .3 and self:BaseUltPredictIfUltCanKill(snipeTarget) then
                CastSpell(_R, self:BaseUltGetBaseCoords().x, self:BaseUltGetBaseCoords().z)
            end
        end
    end
end
function Jinx:recallFunction(Hero, Status)
	local o = Hero
	if o and o.valid and o.type == 'AIHeroClient' then
		local str = Status
		if self.recallTimes[str:lower()] then
			if LulzMenu.General.Verbose then
				if not o.visible and self.lasttime[o.networkID]  then
					print(r.name.." is recalling. Last seen "..string.format("%.1f", os.clock() -self.lasttime[o.networkID], 1).." seconds ago." )
				end
			end
			self.activeRecalls[o.networkID] = {
            					name = o.charName,
            					startT = os.clock(),
            					duration = self.recallTimes[str:lower()],
            					endT = os.clock() + self.recallTimes[str:lower()],
                                startHP = o.health,
                                hpRegen = o.hpRegen,
                                object = o
            				}
			return
		elseif self.activeRecalls[o.networkID] then
			if self.activeRecalls[o.networkID] and self.activeRecalls[o.networkID].endT > os.clock() then
				if LulzMenu.General.Verbose then
					print(self.activeRecalls[o.networkID].name.." canceled recall")
				end
				recallTime = nil
				recallName = nil
				blockName = nil
				self.activeRecalls[o.networkID] = nil
				return
			else
				if junglerName == self.activeRecalls[o.networkID].name then
					jungleText = "Recalled"
				end
				if LulzMenu.General.Verbose then
					print(self.activeRecalls[o.networkID].name.." finished recall")
				end
				self.activeRecalls[o.networkID] = nil
				recallTime = nil
				recallName = nil
				blockName = nil
				return
			end
		end
	end
end
function Jinx:AddToMenu()
    LulzMenu.Draw.RSettings:addParam("BaseUlt", "Draw baseult tracker", 1, true)

    LulzMenu.Spell.QMenu:addParam("EnableCombo", "Use in combo", 1, true)
    LulzMenu.Spell.QMenu:addParam("EnableHarass", "Use in harass", 1, true)
    LulzMenu.Spell.QMenu:addParam("EnableClear", "Use in clear", SCRIPT_PARAM_LIST, 1,{"Off","Last Hit","Clear"})
    LulzMenu.Spell.QMenu:addParam("EnableJungle", "Use in jungle", 1, true)
    LulzMenu.Spell.QMenu:addParam("EnableKs", "Use to KS", 1, true)
    LulzMenu.Spell.QMenu:addParam("EnableFlee", "Use to flee with iceborn", 1, true)
    LulzMenu.Spell.QMenu:addParam("PlaceHolder", "", SCRIPT_PARAM_INFO, "")
    LulzMenu.Spell.QMenu:addParam("HarassMana", "Harass mana managment % >", SCRIPT_PARAM_SLICE, 30, 0, 100, 0)
    LulzMenu.Spell.QMenu:addParam("ClearMana", "Lane clear mana managment % >", SCRIPT_PARAM_SLICE, 60, 0, 100, 0)
    LulzMenu.Spell.QMenu:addParam("PlaceHolder2", "", SCRIPT_PARAM_INFO, "")
    Prediction:AddToMenu(LulzMenu.Spell.QMenu)

    LulzMenu.Spell.WMenu:addParam("EnableCombo", "Use in combo", 1, true)
    LulzMenu.Spell.WMenu:addParam("EnableHarass", "Use in harass", 1, false)
    LulzMenu.Spell.WMenu:addParam("EnableClear", "Use in clear", 1, false)
    LulzMenu.Spell.WMenu:addParam("EnableKs", "Use to KS", 1, true)
    LulzMenu.Spell.WMenu:addParam("PlaceHolder", "", SCRIPT_PARAM_INFO, "")
    LulzMenu.Spell.WMenu:addParam("HarassMana", "Harass mana managment % >", SCRIPT_PARAM_SLICE, 30, 0, 100, 0)
    LulzMenu.Spell.WMenu:addParam("ClearMana", "Lane clear mana managment % >", SCRIPT_PARAM_SLICE, 60, 0, 100, 0)
    LulzMenu.Spell.WMenu:addParam("PlaceHolder2", "", SCRIPT_PARAM_INFO, "")
    Prediction:AddToMenu(LulzMenu.Spell.WMenu)

    LulzMenu.Spell.EMenu:addParam("Enable", "Use as gap closer", SCRIPT_PARAM_LIST, 1,{"Never", "Combo", "Combo+Harass"})
    LulzMenu.Spell.EMenu:addParam("EnableKs", "Use to KS", 1, true)
    LulzMenu.Spell.EMenu:addParam("EnableFlee", "Use to flee", 1, true)
    LulzMenu.Spell.EMenu:addParam("PlaceHolder", "", SCRIPT_PARAM_INFO, "")
    LulzMenu.Spell.EMenu:addParam("HarassMana", "Harass mana managment % >", SCRIPT_PARAM_SLICE, 30, 0, 100, 0)

    LulzMenu.Spell.RMenu:addParam("EnableCombo", "Use in combo", 1, true)
    LulzMenu.Spell.RMenu:addParam("ComboRangeCheck", "Combo ult range check", SCRIPT_PARAM_SLICE, 800, 0, 9000, 0)
    LulzMenu.Spell.RMenu:addParam("PlaceHolder44", "", SCRIPT_PARAM_INFO, "")
    LulzMenu.Spell.RMenu:addParam("BaseUlt", "Enable base ult", 1, true)
    LulzMenu.Spell.RMenu:addParam("PlaceHolder3", "", SCRIPT_PARAM_INFO, "")
    LulzMenu.Spell.RMenu:addParam("EnableSnipe", "Ult to global snipe", 1, true)
    LulzMenu.Spell.RMenu:addParam("SnipeRangeCheckMax", "Global snipe max range check", SCRIPT_PARAM_SLICE, 1500, 300, 9000, 0)
    LulzMenu.Spell.RMenu:setCallback("SnipeRangeCheckMax", function(v)
        LulzMenu.Spell.RMenu:removeParam("SnipeRangeCheckMin")
        LulzMenu.Spell.RMenu:addParam("SnipeRangeCheckMin", "Global snipe min range check", SCRIPT_PARAM_SLICE, 1500, 0, v, 0)
        if LulzMenu.Spell.RMenu.SnipeRangeCheckMin > v then LulzMenu.Spell.RMenu.SnipeRangeCheckMin = v - 300 end
    end)
    LulzMenu.Spell.RMenu:addParam("SnipeRangeCheckMin", "Global snipe min range check", SCRIPT_PARAM_SLICE, 1200, 0, 9000, 0)
    LulzMenu.Spell.RMenu:addParam("PlaceHolder23", "", SCRIPT_PARAM_INFO, "")


    LulzMenu.Spell.RMenu:addParam("EnableInitiator", "Use on initiators", 1, true)
    LulzMenu.Spell.RMenu:addParam("InitiatorRangeCheck", "Initiators ult range check", SCRIPT_PARAM_SLICE, 2000, 0, 9000, 0)
    LulzMenu.Spell.RMenu:addParam("InitiateNum", "Min number of enemies to ult", SCRIPT_PARAM_SLICE, 1, 1, 5, 0)
    LulzMenu.Spell.RMenu:addParam("PlaceHolder2", "", SCRIPT_PARAM_INFO, "")
    Prediction:AddToMenu(LulzMenu.Spell.RMenu)
end
function Jinx:GetDamage(spell, unit)
    if spell == "ALL" then
        local sum = 0
          for spell, func in pairs(self.spellDmg) do
            sum = sum + (func(unit) or 0)
          end
         return sum
       else
          return self.spellDmg[spell](unit) or 0
       end
end
function Jinx:OnTick()
    self.QState = myHero:CanUseSpell(_Q) == READY
    self.WState = myHero:CanUseSpell(_W) == READY
    self.EState = myHero:CanUseSpell(_E) == READY
    self.RState = myHero:CanUseSpell(_R) == READY
    self.manaPercent = myHero.mana / myHero.maxMana * 100
    _G.Target = Orbwalker:GetOrbwalkerTarget(1100)

    self:Combo()
    self:Harass()
    self:LaneClear()
    --self:KillSteal()
    self:FleeMode()
    self:BaseUlt()
end
function Jinx:OnDraw()
    local function ReturnColor(color) return ARGB(color[1],color[2],color[3],color[4]) end
    local function BaseUltProgressBar(x, y, percent, text, tick)
        DrawRectangle(x, y - 5, 300, 40, ARGB(255,100,100,100))
        DrawRectangle(x + 5, y, 290, 30, ARGB(255,30,30,30))
        DrawRectangle(x + 5, y, (percent/100)*290, 30, ARGB(255,255,0,0))
        DrawRectangle(x + (6.9 / 7.9 * 290), y, (100/100)*290 - x + (6.9 / 7.9 * 290), 30, ARGB(100,30,30,30))
        if tick <= 100 then
            DrawRectangle(x + 5 + (tick/100)*290, y, 2, 30, ARGB(255,0,255,0))
        else
            DrawRectangle(x + 5 + (100/100)*290, y, 2, 30, ARGB(255,0,255,0))
        end
        DrawText(text,20,y + 8,x + 5,ARGB(255,255,255,255))
    end

    if not myHero.dead then
        if LulzMenu.Draw.AASettings.Enabled then
            DrawCircle3D(myHero.x, myHero.y, myHero.z, myHero.range + myHero.boundingRadius, 1, ReturnColor(LulzMenu.Draw.AASettings.CircleColor), 100)
        end
        if LulzMenu.Draw.QSettings.Enabled and (self.QState or not LulzMenu.Draw.QSettings.Hide) then
            DrawCircle3D(myHero.x, myHero.y, myHero.z, self.SpellTable.Q.range, 1, ReturnColor(LulzMenu.Draw.QSettings.CircleColor), 100)
        end
        if LulzMenu.Draw.WSettings.Enabled and (self.WState or not LulzMenu.Draw.WSettings.Hide) then
            DrawCircle3D(myHero.x, myHero.y, myHero.z, self.SpellTable.W.range, 1, ReturnColor(LulzMenu.Draw.WSettings.CircleColor), 100)
        end
        if LulzMenu.Draw.ESettings.Enabled and (self.EState or not LulzMenu.Draw.ESettings.Hide) then
            DrawCircle3D(myHero.x, myHero.y, myHero.z, self.SpellTable.E.range, 1, ReturnColor(LulzMenu.Draw.ESettings.CircleColor), 100)
        end
        if LulzMenu.Draw.ESettings.Enabled and (self.EState or not LulzMenu.Draw.ESettings.Hide) then
            DrawCircle3D(myHero.x, myHero.y, myHero.z, self.SpellTable.E.maxRange, 1, ReturnColor(LulzMenu.Draw.ESettings.CircleColor), 100)
        end
        if LulzMenu.Draw.RSettings.Enabled and (self.RState or not LulzMenu.Draw.RSettings.Hide) then
            DrawCircleMinimap(myHero.x, myHero.y, myHero.z, LulzMenu.Spell.RMenu.SnipeRangeCheckMax, 1, ReturnColor(LulzMenu.Draw.RSettings.CircleColor), 50)
            DrawCircleMinimap(myHero.x, myHero.y, myHero.z, LulzMenu.Spell.RMenu.SnipeRangeCheckMin, 1, ReturnColor(LulzMenu.Draw.RSettings.CircleColor), 50)
            for i, enemy in pairs(self.enemyHeros) do
                if enemy and ValidTarget(enemy) then
                    if self.RState and self:GetDamage(_R,enemy) > enemy.health and GetDistance(enemy) < LulzMenu.Spell.RMenu.SnipeRangeCheckMax and GetDistance(enemy) > LulzMenu.Spell.RMenu.SnipeRangeCheckMin then
                        DrawTextA("You can kill 1 or more enemies, Hold your Force ult key!", 25, WINDOW_H / 2, 50, ARGB(255,255,0,0), "center", "center")
                    end
                end
            end
        end
        if LulzMenu.Draw.DrawTarget then
            if Target ~= nil then
                DrawCircle3D(Target.x, Target.y, Target.z, 100, 1, ARGB(255,255,0,0), 100)
            end
        end
        if LulzMenu.Spell.RMenu.BaseUlt and LulzMenu.Draw.RSettings.BaseUlt then
            for i, enemy in pairs(self.activeRecalls) do
                 if self:BaseUltPredictIfUltCanKill(enemy) then
                     BaseUltProgressBar(500,500,(enemy.endT - os.clock()) / 7.9 * 100, enemy.name, ((GetDistance(myHero, self:BaseUltGetBaseCoords()) / 2500) + 1.5) / 8 * 100)
                 end
            end
        end
    end
end
function Jinx:BaseUltGetBaseCoords()
    if myHero.team == 100 then
        return self.BaseSpots[2]
    else
        return self.BaseSpots[1]
    end
end
function Jinx:BaseUltPredictIfUltCanKill(target)
    if myHero.charName == "Ezreal" or myHero.charName == "Jinx" or myHero.charName == "Draven" or myHero.charName == "Ashe" then
        if self:GetDamage(_R, target.object) > target.startHP + (target.hpRegen * 7.9)  then
            return true
        else
            return false
        end
    end
end
function Jinx:CastQ(enemy)
    if self.QState then
        local CastPosition, HitChance, Info = Prediction:GetLineCastPosition(enemy, self.SpellTable.Q, "Q")
        if CastPosition and HitChance >= LulzMenu.Spell.QMenu.Accuracy then
            if Info ~= nil and Info.collision ~= nil and not Info.collision or Info == nil or Info.collision == nil then
                CastSpell(_Q, CastPosition.x, CastPosition.z)
            end
        end
    end
end
function Jinx:CastW(enemy)
    local CastPosition, HitChance, Info = Prediction:GetLineCastPosition(enemy, self.SpellTable.W, "W")
    if CastPosition and HitChance >= LulzMenu.Spell.WMenu.Accuracy then
        CastSpell(_W, CastPosition.x, CastPosition.z)
    end
end
function Jinx:CastE(x,z)
    if self.EState then
        CastSpell(_E, x, z)
    end
end
function Jinx:CastR(enemy)
    local CastPosition, HitChance, Info = Prediction:GetLineCastPosition(enemy, self.SpellTable.R)
    if CastPosition and HitChance >= LulzMenu.Spell.RMenu.Accuracy then
        CastSpell(_R, CastPosition.x, CastPosition.z)
    end
end
function Jinx:Combo()
    if Orbwalker:IsFighting() then
        if ValidTarget(Target) then
            if self.QState then
                self:CastQ(Target)
            end

            if self.WState then
                self:CastW(Target)
            end
        end
    end
end
function Jinx:Harass()
    if Orbwalker:IsHarassing() then
        if ValidTarget(Target) then
            if self.QState and LulzMenu.Spell.QMenu.EnableHarass then
                self:CastQ(Target)
            end

            if self.WState and LulzMenu.Spell.WMenu.EnableHarass then
                self:CastW(Target)
            end
        end
    end
end
function Jinx:LaneClear()
    if Orbwalker:IsLaneClearing() then
        if LulzMenu.Spell.QMenu.EnableJungle then
            self.jungleMinions:update()

            if self.QState then
                for i, jungle in pairs(self.jungleMinions.objects) do
                    if jungle ~= nil and ValidTarget(jungle) and GetDistance(jungle) < self.SpellTable.Q.range and string.split(jungle.charName,'_')[2] ~= "Plant" then
                        self:CastQ(jungle)
                    end
                end
            end
        end

        if LulzMenu.Spell.QMenu.EnableClear > 1 then
            self.enemyMinions:update()
            if self.QState then
                for i, minion in pairs(self.enemyMinions.objects) do
                    if minion ~= nil and ValidTarget(minion) and GetDistance(minion) < self.SpellTable.Q.range then
                        if LulzMenu.Spell.QMenu.EnableClear == 3 then
                            self:CastQ(minion)
                        else
                            if self:GetDamage(_Q, minion) > minion.health then
                                self:CastQ(minion)
                            end
                        end
                    end
                end
            end
        end
    end
end
function Jinx:KillSteal()
    for i, enemy in pairs(self.enemyHeros) do
        if enemy and ValidTarget(enemy) then
            if LulzMenu.Spell.EMenu.EnableKs then
                if GetDistance(enemy) > self.SpellTable.Q.range and GetDistance(enemy) < (self.SpellTable.Q.range + self.SpellTable.E.range) then
                    if enemy.health < (getDmg("Q", enemy, myHero)+((myHero.damage)*1.1)+(myHero.ap*0.4)) then
                        local p = myHero + (Vector(enemy.pos) - myHero):normalized() * 475
                        self:CastE(p.x,p.z)
                        DelayAction((function() self:CastQ(enemy) end), .3)

                    end
                end
            end

            if LulzMenu.Spell.QMenu.EnableKs then
                if self:GetDamage(_Q, enemy) > enemy.health and enemy.health < self:GetDamage(_W, enemy) then
                    self:CastQ(enemy)
                end
            end

            if LulzMenu.Spell.WMenu.EnableKs then
                if self:GetDamage(_Q, enemy) < enemy.health and enemy.health > self:GetDamage(_W, enemy) then
                    self:CastW(enemy)
                end
            end

            if LulzMenu.Hotkeys.ForceUlt then
                if self.RState and self:GetDamage(_R, enemy) > enemy.health and GetDistance(enemy) < LulzMenu.Spell.RMenu.SnipeRangeCheckMax and GetDistance(enemy) > LulzMenu.Spell.RMenu.SnipeRangeCheckMin then
                    self:CastR(enemy)
                end
            end
        end
    end
end
function Jinx:FleeMode()
    if LulzMenu.Hotkeys.FleeKey then
        myHero:MoveTo(mousePos.x, mousePos.z)

        if LulzMenu.Spell.QMenu.EnableFlee then
            if ItemsAndSummoners:HasItem(3025) then
                self:CastQ(Target)
            end
        end
    end
end
